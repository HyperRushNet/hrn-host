class PlayCanvasHelper{constructor(e,o={}){this.app=new pc.Application(e,{mouse:new pc.Mouse(e),touch:new pc.TouchDevice(e)}),this.app.start(),this.app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW),this.app.setCanvasResolution(pc.RESOLUTION_AUTO),window.addEventListener("resize",()=>this.app.resizeCanvas()),this.app.scene.gammaCorrection=pc.GAMMA_SRGB,this.app.scene.toneMapping=pc.TONEMAP_ACES,this.entities={},typeof CANNON!="undefined"&&this.initPhysics(),o.initCamera!==!1&&(this.entities.camera=this.createCamera(o.cameraPosition||[0,3,6])),o.initLight!==!1&&(this.entities.light=this.createLight(o.lightPosition||[10,10,10])),this.physicsObjects=[],this.world&&this.app.on("update",t=>{const n=1/60;this.world.step(n);for(const{entity:e,body:o}of this.physicsObjects){const t=o.position;e.setPosition(t.x,t.y,t.z);const n=o.quaternion;e.setRotation(n.x,n.y,n.z,n.w)}})}initPhysics(){this.world=new CANNON.World,this.world.gravity.set(0,-9.82,0),this.world.broadphase=new CANNON.NaiveBroadphase,this.world.solver.iterations=10,this.physicsMaterial=new CANNON.Material("defaultMaterial");const e=new CANNON.ContactMaterial(this.physicsMaterial,this.physicsMaterial,{friction:.4,restitution:.3});this.world.addContactMaterial(e)}createFlatBoxMesh(e){const o=this.app,t=e.map(e=>e/2),n=[-t[0],-t[1],t[2],t[0],-t[1],t[2],t[0],t[1],t[2],-t[0],t[1],t[2],t[0],-t[1],-t[2],-t[0],-t[1],-t[2],-t[0],t[1],-t[2],t[0],t[1],-t[2],-t[0],-t[1],-t[2],-t[0],-t[1],t[2],-t[0],t[1],t[2],-t[0],t[1],-t[2],t[0],-t[1],t[2],t[0],-t[1],-t[2],t[0],t[1],-t[2],t[0],t[1],t[2],-t[0],t[1],t[2],t[0],t[1],-t[2],-t[0],t[1],-t[2],-t[0],-t[1],-t[2],t[0],-t[1],-t[2],t[0],-t[1],t[2],-t[0],-t[1],t[2]],r=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1],a=[0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,1,0,1];const i=new pc.VertexFormat(o.graphicsDevice,[{semantic:pc.SEMANTIC_POSITION,components:3,type:pc.TYPE_FLOAT32},{semantic:pc.SEMANTIC_NORMAL,components:3,type:pc.TYPE_FLOAT32},{semantic:pc.SEMANTIC_TEXCOORD0,components:2,type:pc.TYPE_FLOAT32}]),l=new pc.VertexBuffer(o.graphicsDevice,i,24),s=new Float32Array(24*8);for(let c=0;c<24;c++)s[8*c]=n[3*c],s[8*c+1]=n[3*c+1],s[8*c+2]=n[3*c+2],s[8*c+3]=r[3*c],s[8*c+4]=r[3*c+1],s[8*c+5]=r[3*c+2],s[8*c+6]=a[2*c],s[8*c+7]=a[2*c+1];l.setData(s);const d=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23],m=new pc.IndexBuffer(o.graphicsDevice,pc.INDEXFORMAT_UINT16,d.length);return m.setData(new Uint16Array(d)),this.mesh=new pc.Mesh,this.mesh.vertexBuffer=l,this.mesh.indexBuffer[0]=m,this.mesh.primitive[0].type=pc.PRIMITIVE_TRIANGLES,this.mesh.primitive[0].base=0,this.mesh.primitive[0].count=d.length,this.mesh}createBox(e={}){var o=this,t=e.position||[0,0,0],n=e.size||[1,1,1],r=e.color||[1,1,1],a=e.name||"Box",i=e.mass||1,l=e.textureUrl||null,s=e.rotation||[0,0,0];const c=new pc.Entity(a),u=this.createFlatBoxMesh(n),m=new pc.StandardMaterial;let f=new pc.MeshInstance(u,m);c.addComponent("render"),c.render.meshInstances=[f],c.setPosition(...t),c.setEulerAngles(...s),this.app.root.addChild(c),l&&(this.app.assets.loadFromUrl(l,"texture",function(e){m.diffuseMap=e.resource,m.diffuseMapAddressU=pc.ADDRESS_CLAMP_TO_EDGE,m.diffuseMapAddressV=pc.ADDRESS_CLAMP_TO_EDGE,m.diffuseMapTiling=new pc.Vec2(n[0],n[2]),m.update()}));if(this.world){const e=new CANNON.Vec3(n[0]/2,n[1]/2,n[2]/2),o=new CANNON.Box(e),r=new CANNON.Body({mass:i,shape:o,position:new CANNON.Vec3(...t),quaternion:new CANNON.Quaternion().setFromEuler(s[0]*Math.PI/180,s[1]*Math.PI/180,s[2]*Math.PI/180,"XYZ"),material:this.physicsMaterial,linearDamping:.05,angularDamping:.05});this.world.addBody(r),this.physicsObjects.push({entity:c,body:r})}return c}createPlane(e={}){const{o:e.position||[0,0,0],t:e.rotation||[0,0,0],n:e.size||[10,10],r:e.color||[.2,.2,.2],a:e.name||"Plane"}=e,i=new pc.Entity(a);i.addComponent("model",{type:"box"}),i.setLocalScale(n[0],.1,n[1]),i.setPosition(...o),i.setEulerAngles(...t);const l=new pc.StandardMaterial;l.diffuse=new pc.Color(...r),l.update(),i.model.material=l,this.app.root.addChild(i),this.world&&(function(e,t,n){const r=new CANNON.Box(new CANNON.Vec3(t[0]/2,.05,t[1]/2)),a=new CANNON.Body({mass:0,shape:r,position:new CANNON.Vec3(...e),quaternion:new CANNON.Quaternion().setFromEuler(t[0]*Math.PI/180,t[1]*Math.PI/180,t[2]*Math.PI/180),material:this.physicsMaterial});this.world.addBody(a),this.physicsObjects.push({entity:n,body:a})}.call(this,o,t,i));return i}createCamera(e=[0,0,3],o=[0,0,0]){const t=new pc.Entity("Camera");return t.addComponent("camera",{clearColor:new pc.Color(.1,.1,.1)}),t.setPosition(...e),t.lookAt(new pc.Vec3(...o)),this.app.root.addChild(t),this.app.camera=t,t}createLight(e=[10,10,10],o=[1,1,1],t=1){const n=new pc.Entity("Directional Light");return n.addComponent("light",{type:"directional",color:new pc.Color(...o),intensity:t,castShadows:!0,shadowBias:.05,shadowDistance:50,normalOffsetBias:.01}),n.setPosition(...e),n.setEulerAngles(45,45,0),this.app.root.addChild(n),n}enableMouseRotation(e,o={}){const t=o.sensitivity||.3;let n=!1,r=0,a=0,i=0,l=0,s=this.app.graphicsDevice.canvas;s.addEventListener("mousedown",e=>{n=!0,r=e.clientX,a=e.clientY}),window.addEventListener("mouseup",()=>{n=!1}),window.addEventListener("mousemove",o=>{if(!n)return;const s=o.clientX-r,d=o.clientY-a;r=o.clientX,a=o.clientY,i-=s*t,l-=d*t,l=Math.max(-89,Math.min(89,l));const m=new pc.Quat().setFromEulerAngles(0,i,0),c=new pc.Quat().setFromEulerAngles(l,0,0),u=new pc.Quat;u.mul2(m,c),e.setRotation(u)})}}
